<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>ContentFilters</key>
	<dict/>
	<key>auto_connect</key>
	<true/>
	<key>data</key>
	<dict>
		<key>connection</key>
		<dict>
			<key>colorIndex</key>
			<integer>5</integer>
			<key>database</key>
			<string>dev_holdemclub</string>
			<key>host</key>
			<string>dev-holdemclub.ccchnydnz10o.ap-northeast-2.rds.amazonaws.com</string>
			<key>kcid</key>
			<string>1068083525478395249</string>
			<key>name</key>
			<string>HOLDEMCLUB_DEV</string>
			<key>rdbms_type</key>
			<string>mysql</string>
			<key>sslCACertFileLocation</key>
			<string></string>
			<key>sslCACertFileLocationEnabled</key>
			<integer>0</integer>
			<key>sslCertificateFileLocation</key>
			<string></string>
			<key>sslCertificateFileLocationEnabled</key>
			<integer>0</integer>
			<key>sslKeyFileLocation</key>
			<string></string>
			<key>sslKeyFileLocationEnabled</key>
			<integer>0</integer>
			<key>type</key>
			<string>SPTCPIPConnection</string>
			<key>useSSL</key>
			<integer>0</integer>
			<key>user</key>
			<string>devholdemclub</string>
		</dict>
		<key>session</key>
		<dict>
			<key>connectionEncoding</key>
			<string>utf8mb4</string>
			<key>contentFilter</key>
			<dict/>
			<key>contentPageNumber</key>
			<integer>1</integer>
			<key>contentSelection</key>
			<data>
			YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFy
			Y2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJX
			TlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAF
			gAdUdHlwZVRyb3dzXxAdU2VsZWN0aW9uRGV0YWlsVHlwZU5TSW5k
			ZXhTZXTSFwsYGVxOU1JhbmdlQ291bnQQAIAG0hscHR5aJGNsYXNz
			bmFtZVgkY2xhc3Nlc1pOU0luZGV4U2V0oh8gWk5TSW5kZXhTZXRY
			TlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVk
			QXJjaGl2ZXLRJidUZGF0YYABAAgAEQAaACMALQAyADcAQABGAE0A
			VQBgAGcAagBsAG4AcQBzAHUAdwB8AIEAoQCmALMAtQC3ALwAxwDQ
			ANsA3gDpAPIA9wEEAQcBGQEcASEAAAAAAAACAQAAAAAAAAAoAAAA
			AAAAAAAAAAAAAAABIw==
			</data>
			<key>contentSortColIsAsc</key>
			<true/>
			<key>contentViewport</key>
			<string>{{0, 0}, {2450, 1260}}</string>
			<key>isToolbarVisible</key>
			<true/>
			<key>queries</key>
			<string>
select * from `recommend_channel` as rc
where rc.active = true
order by `priority` desc
limit 3;


select *
from `channel` as c
left join `group` as g
on c.group_id = g.group_id
where c.`active`=true
order by c.priority desc, c.title asc;


select c.channel_id, if(g.group_id is null, c.title , g.title) as title
from `channel` as c
left join `group` as g
on c.group_id = g.group_id
where c.`active`=true
group by g.group_id
order by c.priority desc, c.title asc;

select distinct(g.group_id), c.channel_id, if(g.group_id is null, c.title , g.title) as title
from `channel` as c
left join `group` as g
on c.group_id = g.group_id
where c.`active`=true
group by g.group_id 
order by c.priority desc, c.title asc;





select *
from `channel` as c
left join `group` as g
on c.group_id = g.group_id
where c.`active`=true
group by g.group_id
order by c.priority desc, c.title asc;


select count(*) as total, c.title, g.title, c.priority
from `channel` as c
left join `group` as g
on c.group_id = g.group_id
where c.`active`=true
group by g.group_id
order by c.priority desc, c.title asc;


select c.title, g.title, c.priority
from `channel` as c
left join `group` as g
on c.group_id = g.group_id
where c.active=true
order by c.priority desc, c.title asc;

select 
distinct(c.title) as channel_title, g.title as group_title, c.priority, g.group_id as group_id, c.channel_id as channel_id
from `channel` as c
left join `group` as g
on c.group_id = g.group_id
where c.active=true
order by c.priority desc, c.title asc;

# 모든 컨텐츠 가져오기
select 
distinct(c.title) as channel_title, g.title as group_title, c.priority, g.group_id as group_id, c.channel_id as channel_id
from `channel` as c
left join `group` as g
on c.group_id = g.group_id
where c.active=true
order by c.priority asc, g.priority asc, c.title asc; 

## 그룹간 순서를 지정할 수 있어야 한다.
## 만약 그룹과 채널간 경쟁이 있을 경우 어떻게 정렬을 해서 가져올 수 있는가?
# 모든 콘텐츠를 가져온 다음 이것들을 규칙을 정해서 정렬을 다시 한다.
# display_title, group_id, channel_id(,,,), group_title
# sub_channel이 있는 것과 없는 것을 구분할 수 있어야 한다.
# sub_channel의 경우 해당 채널 아래로 이동시킨다.

select 
g.group_id, group_concat(c.channel_id) as channel_id, 
c.title as channel_title,  g.title as group_title, 
c.priority as c_priority, g.priority as g_priority, count(c.`channel_id`) as sub_channel_count
from `channel` as c
left join `group` as g
on c.group_id = g.group_id
where c.active=true
group by g.group_id
order by c.priority desc, c.title asc;


select 
g.group_id, group_concat(c.channel_id) as channel_id, 
c.title as channel_title,  g.title as group_title, 
c.priority as c_priority, g.priority as g_priority, count(c.`channel_id`) as sub_channel_count
from `channel` as c
left join `group` as g
on c.group_id = g.group_id
where c.active=true
group by g.group_id
order by c.priority asc;

# 15개의 단독 채널과 그룹 채널이 출력되어야 한다. 순서는 priority asc이다.
select 
c.channel_id as channel_id, g.group_id as group_id, 
c.title as channel_title,  g.title as group_title, 
c.priority as c_priority
from `channel` as c
left join `group` as g
on c.group_id = g.group_id
where c.active=true
group by c.channel_id
order by c.priority asc;

# 단독 채널일 경우 sub ""
# 그룹 채널일 경우 sub에 title의 묶음과 channel_id의 묶음을 출력해보자.
# order로 출력한 것과는 다르게 group이 되고 있는 모습을 볼 수 있다. =&gt; 블로그로 포스팅할 것
## concat vs. group_concat vs. group_concat order by


select
c.channel_id as channel_id, if(g.group_id is null, c.title ,g.group_id) as group_id,
c.title as channel_title,  g.title as group_title, c.priority as c_priority, count(g.`group_id`) as total
,group_concat(c.`channel_id` order by c.priority asc) as group_channel
,group_concat(c.title order by c.priority asc) as group_channel_title
,group_concat(c.priority order by c.priority asc) as group_priority
from `channel` as c
left join `group` as g
on c.group_id = g.group_id
where c.active=true
group by group_id
order by c.priority asc;


select
#c.channel_id as channel_id, 
if(g.group_id is null, c.title ,g.group_id) as group_id,
#c.title as channel_title,  
#g.title as group_title, c.priority as c_priority, 
#count(g.`group_id`) as total,
if(count(g.`group_id`)=0,'single','group') as type
,group_concat(c.`channel_id` order by c.priority asc) as group_channel_id
,group_concat(c.title order by c.priority asc) as group_channel_title
,if(g.title is null, c.title, g.title) as title
#,group_concat(c.priority order by c.priority asc) as group_priority
from `channel` as c
left join `group` as g
on c.group_id = g.group_id
where c.active=true
group by group_id
order by c.priority asc;





select
#c.channel_id as channel_id, 
if(g.group_id is null, c.title ,g.group_id) as group_id,
#c.title as channel_title,  
#g.title as group_title, c.priority as c_priority, 
#count(g.`group_id`) as total,
if(count(g.`group_id`)=0,'single','group') as type
,group_concat(c.`channel_id` order by c.priority asc) as group_channel_id
,group_concat(c.title order by c.priority asc) as group_channel_title
,if(g.title is null, c.title, g.title) as title
#,group_concat(c.priority order by c.priority asc) as group_priority
from `channel` as c
left join `group` as g
on c.group_id = g.group_id
where c.active=true
group by group_id
order by c.priority asc;


select
if(g.title is null, c.title, g.title) as title,
if(count(g.`group_id`)=0,'single','group') as type,
group_concat(c.`channel_id` order by c.priority asc) as group_channel_id,
group_concat(c.title order by c.priority asc) as group_channel_title,
if(g.group_id is null, c.title ,g.group_id) as group_id
from `channel` as c
left join `group` as g
on c.group_id = g.group_id
where c.active=true
group by group_id
order by c.priority asc;


# 추천채널과 채널 테이블을 연결함. ==&gt; 리얼에 반영할 것.
alter table `recommend_channel`
add foreign key (`channel_id`)
references `channel`(`channel_id`);

###################################
###################################
######### 여기서부터 v2.0 ############
###################################
###################################
create table `broadcast`(
	id bigint not null auto_increment,
	date datetime default CURRENT_TIMESTAMP,
	status boolean default true,
	link varchar(255) character set utf8 default null,
	primary key(`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin ROW_FORMAT=COMPACT;

alter table `broadcast` drop column `end_dt`;
alter table `broadcast` add column `end_dt` datetime default null after `date`;

alter table `broadcast` drop column `date`;
alter table `broadcast` add column `start_dt` datetime default CURRENT_TIMESTAMP after `id`;



# insert into `broadcast` (`link`) values('');
## 쿼리로 한방에 해결하는 방법을 찾아보자.

insert into `broadcast` ('link')
select link
where date(`date`) = CURDATE();




select `id`, `date`, `link`, `status` from `broadcast`
where date(`date`) = curdate();

insert into `broadcast` (`link`) values('http://www.google.com');

select * from `broadcast` where date(`date`) = curdate();

# 이건 문법에 문제가 있다고 출력된다.
IF EXISTS (select * from `broadcast`)
BEGIN
print 'no rows'
END;

## 아래와 같은 방법도 사용하지 못한다. 
select * from `broadcast` where date(`date`) = curdate();
if @@rowcount=0
begin
print '0'
end;


## select ifnull을 통해서 실행해본다.
#select ifnull( (select `status` from `broadcast` where date(`date`) = curdate()), 0) as result;

##;
## 아래 코드도 실행이 되지 않는다. 문제는 버전에 있는 것인지 아니면 문법에 있는 것인지...
if not exists ( select * from `broadcast` where date(`date`) = curdate() )
then insert into `broadcast` (`link`) values('http://www.google.com')
else update `broadcast` set `status`=false where date(`date`) = curdate()
end if;


/* DROP PROCEDURE `GetFlavour`
CREATE PROCEDURE `GetFlavour`(`FlavourID` INT, `FlavourName` VARCHAR(20))
begin
if not exists ( select * from `broadcast` where date(`date`) = curdate() )
then insert into `broadcast` (`link`) values('http://www.google.com')
else update `broadcast` set `status`=false where date(`date`) = curdate()
end if
end; */

######

select * if(
	exists( select * from `broadcast` where date(`date`) = curdate() ) is null,
	'true',
	'false'
) from `broadcast`;


## 중복일 경우 업데이트를 치는 구문이 있다.
insert into `broadcast` (`link`) values('http://www.google.com')
on duplicate key update `status`=false where date(`date`)=curdate();

## 같은 날 한 번 이상 방송을 할 경우
## insert의 조건, 어떤 것도 방송중이지 않아야 한다.
## 가장 최근에 한 개에 대해서 방송중 여부를 판단한다.


# 최근 방송 여부를 판단하고 방송을 정상적으로 종료를 하지 않은 상태에서는 방송중이라는 신호가 이어진다.
## 현재 방송중인지의 여부를 판단한다. (백오피스와 클라이언트사이드 모두 사용)
select * from `broadcast` 
order by `date` desc
limit 1;

# 방송중일 경우 반드시 해당 아이디를 통해서 방송중인 레코드에 상태값을 update하게 된다
## 만약 하루동안 방송중이라고 켜놓고 다음날에 이어서 방송을 할 경우는 이틀연속 쉬지 않고 방송으르 한 것으로 판단하게 된다.
## 방송중 여부는 항상 최신 레코드를 기준으로 판단하게 된다.
## 방송중일 경우 버튼에 해당 아이디가 있을 것이고 
## 방송중이지 않을 경우 버튼에는 해당 아이디가 없을 것이다.
## 방송중일 경우, 버튼을 누르면 레코드에 update를 하게 되고 with id
## 방송중이지 않을 경우, 새로운 레코드를 insert하게 되고 페이지를 릴로드되면서 버튼에 id를 가지고 있는 방송중 상태가 될 것이다.


select * from `broadcast` 
order by `start_dt` desc limit 1;

### channel ####
select * from `channel`;
alter table `channel` add column `type` enum('G', 'S', 'U') default 'G' after `title`; ## General, Special, Under


# 모든 채널 가져오기
select * from `channel`
order by `priority` desc;


## 대표 채널 가져오기
select * from `channel`
where `type` != 'U'
order by `priority` desc; ## U, S타입인 경우만 group_id를 같는다, G일 경우 단독 채널이다.


create table `channel_group` (
	`id` bigint not null auto_increment,
	`group_id` varchar(255) character set utf8 not null,
	`channel` varchar(255) character set utf8 not null,
	primary key(`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin ROW_FORMAT=COMPACT;


## 데이터가 정상적으로 생성이 된 이후에 참조키를 걸어서 연결할 것!!


select * from `channel`
where group_id is not null;

## 기존 채널과 그룹을 유지하면서 안정적으로 릴리즈하기 위해서 새로운 테이블을 만들어서 진행해보자.

create table `channel_new` (
	`channel_id` varchar(255) character set utf8 not null,
	`title` varchar(255) character set utf8 not null,
	`type` enum('S','G','U') default 'G' comment 'Special(대표채널), General(단독채널), Under(S채널에 종속)',
	`description` text default null,
	`created_dt` datetime default CURRENT_TIMESTAMP,
	`priority` bigint unsigned default null,
	`group_id` varchar(255) character set utf8 default null,
	`hit_count` bigint default 0,
	`active` boolean default true, 
	unique key(`channel_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin ROW_FORMAT=COMPACT;



## 시나리오 대로 실행을 해본다.
# 1. 처음부터 대표 채널을 등록한다.
select * from `channel_new`;
insert into `channel_new` (`channel_id`,`title`, `type`) 
values('08b75690-6d90-11e6-8ac2-b7031c24f9d2', '네임드 쇼다운 라이브', 'S');

# 2. 대표 채널에 속하는 서브 채널을 생성한다.
insert into `channel_new` (`channel_id`,`title`, `type`)
values('385bc900-90f7-11e6-876f-719554daeebf', '네임드 쇼다운 라이브 시즌1', 'U');

select * from `channel_group`;



select cn.*
from `channel_new` as cn
left join `channel_group` as cg
on cn.group_id = cg.group_id
where cn.type != 'U';

select cn.*
from `channel_new` as cn
left join `channel_group` as cg
on cn.group_id = cg.group_id;


select DISTINCT cn.*, cg.group_id, cg.channel_id from `channel_new` as cn
left join `channel_group` as cg
on cn.group_id = cg.group_id
where cn.type !='U';

select * from `channel_new`;



# channel_new와 channel과 channel_group의 channel을 연결한다.
alter table `channel_group`
add foreign key (`channel_id`)
references `channel`(`channel_id`);


## 우선 순위에 맞게 서브 채널을 제외한 모든 채널을 가져온다.
select * from `channel_new`
where `type` != 'U'
order by `priority` desc;


# 그룹 채널을 가져온다.
select * from `channel_group`;

# line 126번 참고


##;
select cn.*, cg.group_id, cg.channel_id from `channel_new` as cn
left join `channel_group` as cg
on cn.group_id = cg.group_id
where cn.type !='U';


# 그룹별로 채널을 묶는다.
select group_id, group_concat(`channel_id`) as channels
from `channel_group`
group by `group_id`;


select cn.*, cg.group_id, cg.channels from `channel_new` as cn
left join (
	select group_id, group_concat(`channel_id`) as channels
	from `channel_group`
	group by `group_id`
) as cg
on cn.group_id = cg.group_id
where cn.type !='U' and cn.active=true
order by cn.priority desc;

# line 181 참고
select group_id, group_concat(`channel_id`) as channels
from `channel_group`
group by `group_id`;


</string>
			<key>table</key>
			<string>channel_new</string>
			<key>view</key>
			<string>SP_VIEW_CUSTOMQUERY</string>
			<key>windowVerticalDividerPosition</key>
			<real>191</real>
		</dict>
	</dict>
	<key>encrypted</key>
	<false/>
	<key>format</key>
	<string>connection</string>
	<key>queryFavorites</key>
	<array/>
	<key>queryHistory</key>
	<array>
		<string>select cn.*, cg.group_id, cg.channels from `channel_new` as cn
left join (
	select group_id, group_concat(`channel_id`) as channels
	from `channel_group`
	group by `group_id`
) as cg
on cn.group_id = cg.group_id
where cn.type !='U' and cn.active=true
order by cn.priority desc</string>
		<string>select group_id, group_concat(`channel_id`) as channels
from `channel_group`
group by `group_id`</string>
		<string>select cn.*, cg.group_id, cg.channels from `channel_new` as cn
left join (
	select group_id, group_concat(`channel_id`) as channels
	from `channel_group`
	group by `group_id`
) as cg
on cn.group_id = cg.group_id
where cn.type !='U'
order by cn.priority desc</string>
		<string>select cn.*, cg.group_id, cg.channels from `channel_new` as cn
left join (
	select group_id, group_concat(`channel_id`) as channels
	from `channel_group`
	group by `group_id`
) as cg
on cn.group_id = cg.group_id
where cn.type !='U'
order by cn.proirity desc</string>
		<string>select cn.*, cg.group_id, cg.channels from `channel_new` as cn
left join (
	select group_id, group_concat(`channel_id`) as channels
	from `channel_group`
	group by `group_id`
) as cg
on cn.group_id = cg.group_id
where cn.type !='U'</string>
		<string>select cn.*, cg.* from `channel_new` as cn
left join (
	select group_id, group_concat(`channel_id`) as channels
	from `channel_group`
	group by `group_id`
) as cg
on cn.group_id = cg.group_id
where cn.type !='U'</string>
		<string>select cn.*, cg.group_id, cg.channel_id from `channel_new` as cn
left join (
	select group_id, group_concat(`channel_id`) as channels
	from `channel_group`
	group by `group_id`
) as cg
on cn.group_id = cg.group_id
where cn.type !='U'</string>
		<string># 그룹별로 
select group_id, group_concat(`channel_id`) as channels
from `channel_group`
group by `group_id`</string>
		<string>select group_id, group_concat(`channel_id`)
from `channel_group`
group by `group_id`</string>
		<string>select * from `channel_group`</string>
		<string># line 126번 참고


##;
select cn.*, cg.group_id, cg.channel_id from `channel_new` as cn
left join `channel_group` as cg
on cn.group_id = cg.group_id
where cn.type !='U'</string>
		<string>select DISTINCT cn.*, cg.group_id, cg.channel_id from `channel_new` as cn
left join `channel_group` as cg
on cn.group_id = cg.group_id
where cn.type !='U'</string>
		<string>select DISTINCT cn.*, cg.group_id, cg.channel_id from `channel_new` as cn
left join `channel_group` as cg
on cn.group_id = cg.group_id</string>
		<string>select distinct cn.*, cg.group_id, cg.channel_id from `channel_new` as cn
left join `channel_group` as cg
on cn.group_id = cg.group_id</string>
		<string>select cn.*, cg.group_id, cg.channel_id from `channel_new` as cn
left join `channel_group` as cg
on cn.group_id = cg.group_id</string>
		<string>select * from `channel_new`</string>
		<string>select cn.*, cg.group_id, cg.channel_id from `channel_new` as cn
left join `channel_group` as cg
on cn.group_id = cg.group_id
where cn.group_id is not null</string>
		<string>select cn.*, cg.* from `channel_new` as cn
left join `channel_group` as cg
on cn.group_id = cg.group_id</string>
		<string>select cn.* from `channel_new` as cn
left join `channel_group` as cg
on cn.group_id = cg.group_id</string>
		<string>select * from `channel_new` as cn
left join `channel_group` as cg
on cn.group_id = cg.group_id</string>
	</array>
	<key>rdbms_type</key>
	<string>mysql</string>
	<key>rdbms_version</key>
	<string>5.6.27-log</string>
	<key>version</key>
	<integer>1</integer>
</dict>
</plist>
